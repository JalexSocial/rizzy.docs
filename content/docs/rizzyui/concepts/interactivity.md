---
title: "Client-Side Interactivity"
description: "Learn how RizzyUI components handle client-side interactions using Alpine.js without relying on Blazor's interactive runtimes."
summary: "Explore RizzyUI's approach to interactivity, leveraging the lightweight Alpine.js framework for common UI behaviors like dropdowns and modals, while remaining compatible with SSR and HTMX."
date: 2024-07-28T10:25:00-05:00 # Adjust date as needed
lastmod: 2024-07-28T10:25:00-05:00 # Adjust date as needed
draft: false
menu:
  docs:
    parent: "concepts"
    identifier: "rizzyui-concepts-interactivity"
weight: 30
toc: true
seo:
  title: "Client-Side Interactivity in RizzyUI (Alpine.js) | Rizzy Documentation"
  description: "Discover how RizzyUI uses Alpine.js for client-side interactions like dropdowns and modals in a server-rendered, HTMX-friendly way, keeping JavaScript minimal and CSP-compliant."
---

## Interactivity: The Alpine.js Sprinkle

RizzyUI components are primarily rendered on the server with Blazor and updated dynamically using HTMX. This server-centric approach is great for performance and SEO. But what about those little client-side interactions needed for a smooth user experience â€“ things like opening a dropdown menu, collapsing an accordion section, or showing/hiding a modal?

Doing these with full server roundtrips via HTMX would be inefficient and clunky. Trying to use Blazor's interactive modes (Server or WebAssembly) for *every* component would negate many benefits of the Rizzy/HTMX approach (like simplicity and reduced client-side overhead).

This is where **Alpine.js** comes into the picture.

### [Why Alpine.js?](#why-alpinejs)

Alpine.js is often described as "Tailwind for JavaScript." It's a rugged, minimal framework for adding behavior to your markup directly in the HTML. It excels at handling simple UI state and interactions without requiring a complex build step or a large runtime library.

RizzyUI uses Alpine.js because:

*   **It's Lightweight:** The footprint is very small, keeping your pages loading fast.
*   **It's Declarative:** You add behavior using simple `x-*` attributes (`x-data`, `x-show`, `x-on:click`, `x-collapse`, etc.) right in your component's markup (`.razor` file).
*   **It Plays Well with SSR/HTMX:** Alpine initializes itself on the existing DOM and doesn't fight with HTMX when parts of the page are swapped. It can easily re-initialize on new content processed by HTMX.
*   **No Build Step Required (Usually):** While RizzyUI bundles it for convenience, Alpine itself can be included via a simple script tag.

### [How RizzyUI Uses Alpine.js: The `rzComponentName` Pattern](#how-rizzyui-uses-alpinejs-the-rzcomponentname-pattern)

You generally **don't need to write Alpine.js code yourself** when using RizzyUI components. RizzyUI encapsulates the necessary Alpine logic within reusable data components.

When you use a RizzyUI component that needs interactivity, like `<Dropdown>`, it will render HTML that includes an `x-data` attribute pointing to a predefined Alpine component specific to that RizzyUI component. For example:

```html
<!-- Simplified output of <Dropdown> -->
<div x-data="rzDropdown" ...>
  <button x-on:click="toggleDropdown" :aria-expanded="dropdownOpen" ...>
    Trigger
  </button>
  <div x-show="dropdownOpen" x-collapse ...>
    Menu Content
  </div>
</div>
```

Here, `x-data="rzDropdown"` tells Alpine to initialize this `div` with the logic defined in the `rzDropdown` component (which handles the `dropdownOpen` state and the `toggleDropdown` function). This logic is included in the RizzyUI JavaScript file.

**What does this mean for you?** Mostly, it just works! You use the RizzyUI Blazor component (`<Dropdown>`, `<Accordion>`, etc.) in your `.razor` files, and the necessary Alpine.js magic is automatically included in the rendered HTML and handled by the RizzyUI JavaScript bundle.

### [Including the RizzyUI JavaScript](#including-the-rizzyui-javascript)

For the Alpine.js interactivity to function, you **must** include the RizzyUI JavaScript bundle in your main layout file (usually `AppLayout.razor`), typically just before the closing `</body>` tag.

You have two options:

1.  **`rizzyui.js` (Standard):** Includes Alpine.js and all RizzyUI Alpine component logic.
    ```html
    <script defer type="module" src="/_content/RizzyUI/dist/rizzyui.js"></script>
    ```

2.  **`rizzyui-csp.js` (CSP-Friendly):** Same as above, but uses the CSP-compatible build of Alpine.js, which avoids `eval()` and is generally preferred if you have a strict Content Security Policy.
    ```html
    <script defer type="module" src="/_content/RizzyUI/dist/rizzyui-csp.js" nonce="@YourNonceValue"></script>
    ```
    *(Remember to replace `@YourNonceValue` with the actual nonce generated by your `IRizzyNonceProvider` if using CSP nonces).*

{{< callout context="note" title="Why `defer` and `type='module'`?" icon="info-circle" >}}
Using `defer` ensures the script executes after the HTML is parsed but before the `DOMContentLoaded` event, which is generally good practice. Using `type="module"` enables modern JavaScript features and helps with dependency management if you were to import other modules (though typically not needed just for RizzyUI).
{{< /callout >}}

### [Content Security Policy (CSP) Considerations](#content-security-policy-csp-considerations)

A key design goal of RizzyUI's interactivity layer is **CSP compliance**.

*   **No Inline Scripts:** RizzyUI components do *not* render inline `<script>` tags or inline event handlers (`onclick="..."`). All event handling is done via Alpine's `x-on:` directives, which attach listeners programmatically.
*   **No `eval()` (with `-csp` build):** The `rizzyui-csp.js` bundle uses the Alpine.js build that avoids `eval()` and related unsafe JavaScript practices. This allows you to implement a stricter CSP (e.g., without `'unsafe-eval'`) for better security.
*   **Nonces:** If your CSP uses nonces (`'nonce-...'`), make sure to include the `nonce` attribute on the `<script>` tag that loads the RizzyUI JS bundle, as shown in the `-csp` example above.

### [Limitations: What Alpine.js *Doesn't* Do Here](#limitations-what-alpinejs-doesnt-do-here)

It's important to remember that Alpine.js in RizzyUI is primarily for **local UI state and simple interactions within a rendered HTML fragment**. It does *not*:

*   Replace Blazor's interactive runtimes for complex C# event handling or state management across components.
*   Handle data fetching or complex business logic (that's still the job of your server-side ASP.NET Core code and HTMX requests).

Think of it as adding just enough client-side smarts to make the server-rendered components feel interactive for common UI patterns like dropdowns, modals, and toggles.

### [Conclusion](#conclusion)

RizzyUI leverages the lightweight power of **Alpine.js** to provide necessary client-side interactivity for components like dropdowns, accordions, and modals, without sacrificing the benefits of server-side rendering and HTMX. By encapsulating Alpine logic within `x-data` components (`rzComponentName`) and providing CSP-friendly JavaScript bundles, RizzyUI offers a clean, maintainable way to add that essential sprinkle of dynamic behavior to your SSR application. Just remember to include the RizzyUI JavaScript file in your layout!
